// services/apiSetup.ts

import api from './api'
import { store } from '../store/store' // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º store
import axios from 'axios'
import { logOut, setAccessToken } from '../store/authSlice/slice'

export const setupApiInterceptors = () => {
  let isRefreshing = false
  let failedQueue: Array<{ resolve: (value?: any) => void; reject: (error?: any) => void }> = []

  const processQueue = (error: any, token: string | null = null) => {
    failedQueue.forEach(({ resolve, reject }) => {
      if (error) {
        reject(error)
      } else {
        resolve(token)
      }
    })
    failedQueue = []
  }

  // ‚úÖ –ò–Ω—Ç–µ—Ä—Ü–µ–ø—Ç–æ—Ä –∑–∞–ø—Ä–æ—Å–æ–≤
  api.interceptors.request.use(
    (config) => {
      const state = store.getState()
      const accessToken = state.auth.tokens.accessToken
      if (accessToken) {
        config.headers.Authorization = `Bearer ${accessToken}`
      }
      return config
    },
    (error) => Promise.reject(error),
  )

  // ‚úÖ –ò–Ω—Ç–µ—Ä—Ü–µ–ø—Ç–æ—Ä –æ—Ç–≤–µ—Ç–æ–≤
  api.interceptors.response.use(
    (response) => response,
    async (error) => {
      const originalRequest = error.config

      if (
        error.response?.status === 401 &&
        !originalRequest._retry &&
        !originalRequest.url?.includes('/user/refresh')
      ) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({ resolve, reject })
          })
            .then((token) => {
              originalRequest.headers.Authorization = `Bearer ${token}`
              return api(originalRequest)
            })
            .catch((err) => Promise.reject(err))
        }

        originalRequest._retry = true
        isRefreshing = true

        try {
          console.log('üîÑ Attempting to refresh token...')
          const refreshAxios = axios.create({
            baseURL: import.meta.env.VITE_API_BASE_URL,
            withCredentials: true,
            headers: {
              'Content-Type': 'application/json',
            },
          })

          const response = await refreshAxios.post('/user/refresh')
          console.log(response.data)
          const { accessToken } = response.data.tokens
          store.dispatch(setAccessToken(response.data))
          // ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π action –∏–∑ authSlice
          // store.dispatch({
          //   type: 'auth/setTokens',
          //   payload: response.data
          // })

          console.log('‚úÖ Token refreshed successfully')
          processQueue(null, accessToken)

          originalRequest.headers.Authorization = `Bearer ${accessToken}`
          return api(originalRequest)
        } catch (refreshError) {
          console.error('‚ùå Token refresh failed:', refreshError)
          processQueue(refreshError, null)
          store.dispatch(logOut())
          return Promise.reject(refreshError)
        } finally {
          isRefreshing = false
        }
      }

      return Promise.reject(error)
    },
  )
}

// let refreshPromise: Promise<any> | null = null;
// let isRefreshing = false;

// // ‚úÖ 1. –ò–Ω—Ç–µ—Ä—Ü–µ–ø—Ç–æ—Ä –∑–∞–ø—Ä–æ—Å–æ–≤ - –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç accessToken
// api.interceptors.request.use(
//   (config) => {
//     const token = localStorage.getItem('accessToken');
//     if (token) {
//       config.headers.Authorization = `Bearer ${token}`;
//     }
//     return config;
//   },
//   (error) => Promise.reject(error)
// );

// // ‚úÖ 2. –ò–Ω—Ç–µ—Ä—Ü–µ–ø—Ç–æ—Ä –æ—Ç–≤–µ—Ç–æ–≤ - –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç 401 –æ—à–∏–±–∫–∏
// api.interceptors.response.use(
//   (response) => response,
//   async (error) => {
//     const originalRequest = error.config;
// console.log("interceptors", error);
//     // ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º 401 –æ—à–∏–±–∫—É –∏ —á—Ç–æ –∑–∞–ø—Ä–æ—Å –µ—â–µ –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–ª—Å—è
//     if (error.response?.status === 401 && !originalRequest._retry) {

//       // ‚úÖ –ï—Å–ª–∏ —É–∂–µ –∏–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞ - –∂–¥–µ–º –µ–≥–æ
//       if (isRefreshing) {
//         try {
//           await refreshPromise;
//           return api(originalRequest);
//         } catch (refreshError) {
//           return Promise.reject(refreshError);
//         }
//       }

//       // ‚úÖ –ü–æ–º–µ—á–∞–µ–º –∑–∞–ø—Ä–æ—Å –∫–∞–∫ –ø–æ–≤—Ç–æ—Ä—è–µ–º—ã–π
//       originalRequest._retry = true;
//       isRefreshing = true;

//       // ‚úÖ –°–æ–∑–¥–∞–µ–º promise –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
//       refreshPromise = new Promise(async (resolve, reject) => {
//         try {
//           console.log('üîÑ Attempting to refresh token...');

//           // ‚úÖ refreshToken –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –≤ cookies
//           const response = await api.post('/auth/refresh');

//           const { accessToken } = response.data;

//           // ‚úÖ –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π accessToken
//           localStorage.setItem('accessToken', accessToken);

//           console.log('‚úÖ Token refreshed successfully');
//           resolve(response.data);
//         } catch (refreshError) {
//           console.error('‚ùå Token refresh failed:', refreshError);

//           // ‚úÖ –ü—Ä–∏ –Ω–µ—É–¥–∞—á–µ –æ—á–∏—â–∞–µ–º —Ç–æ–∫–µ–Ω –∏ —Ä–µ–¥–∏—Ä–µ–∫—Ç–∏–º –Ω–∞ –ª–æ–≥–∏–Ω
//           localStorage.removeItem('accessToken');
//           // window.location.href = '/login';
//           reject(refreshError);
//         } finally {
//           isRefreshing = false;
//           refreshPromise = null;
//         }
//       });

//       try {
//         // ‚úÖ –ñ–¥–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞ –∏ –ø–æ–≤—Ç–æ—Ä—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∑–∞–ø—Ä–æ—Å
//         await refreshPromise;
//         return api(originalRequest);
//       } catch (refreshError) {
//         return Promise.reject(refreshError);
//       }
//     }

//     // ‚úÖ –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ –ø—Ä–æ—Å—Ç–æ —Ä–µ–¥–∂–µ–∫—Ç–∏–º
//     return Promise.reject(error);
//   }
// );

// export default api;

// import type { Store } from '@reduxjs/toolkit'
// import type { RootState } from '../store/store'
// import { logOut, setAccessToken } from '../store/authSlice/slice'
// import { authService } from './auth.service'

// export const setupApiInterceptors = (store: Store<RootState>) => {
//   api.interceptors.request.use((config) => {
//     const token = store.getState().auth.accessToken
//     if (token) {
//       config.headers.Authorization = `Bearer ${token}`
//     }
//     return config
//   })

//   api.interceptors.response.use(
//     (res) => res,
//     async (error) => {
//       const originalRequest = error.config

//       if (error.response?.status === 401 && !originalRequest._retry) {
//         originalRequest._retry = true

//         try {

//             const { data } = await authService.refreshToken();
//             console.log('REFRESH OK:', data);
//             store.dispatch(setAccessToken(data.accessToken));

//           originalRequest.headers.Authorization = `Bearer ${data.accessToken}`
//           return api(originalRequest)
//         } catch (refreshError) {
//             store.dispatch(logOut());
//           return Promise.reject(refreshError)
//         }
//       }

//       return Promise.reject(error)
//     },
//   )
// }

// import type { Store } from "@reduxjs/toolkit";
// import type { RootState } from "../store/store";

// export const setupApiInterceptors = (store: Store<RootState>) => {
//   api.interceptors.request.use((config) => {
//     const token = store.getState().auth.accessToken;
//     if (token) {
//       config.headers.Authorization = `Bearer ${token}`;
//     }
//     return config;
//   });
// };
